---
title: "Proyecto Weather Service (Parte 1): Construyendo el Recolector de Datos con Python y GitHub Actions"
date: 2025-10-25
draft: False
categories: ["Proyectos", "Herramientas"]
tags: ["python", "api", "github actions", "automatizacion", "serverless", "datos", "backend"]
image: weather_backend_collector.png
description: "Primera entrega de la serie sobre c√≥mo construir un servicio meteorol√≥gico. Nos centramos en el backend: conectar a la API de OpenWeatherMap, almacenar datos en CSV y automatizar todo 24/7 gratis con GitHub Actions."
summary: "Empezamos nuestro proyecto meteorol√≥gico creando el motor: un script de Python que habla con una API, guarda datos hist√≥ricos y se ejecuta solo cada d√≠a gracias a GitHub Actions. ¬°Te cuento los trucos y los problemas!"
---

Como coment√© en un post anterior, uno de mis objetivos con Datalaria es "ensuciarme las manos" con proyectos que me permitan aprender y conectar diferentes tecnolog√≠as del mundo de los datos. Hoy empezamos una serie dedicada a uno de esos proyectos: la creaci√≥n de un **servicio meteorol√≥gico global completo**, desde la recolecci√≥n de datos hasta su visualizaci√≥n y predicci√≥n, todo ello sin servidores y con herramientas gratuitas.

En esta primera entrega, nos centraremos en el **coraz√≥n del sistema: el backend recolector de datos**. Veremos c√≥mo construir un "robot" que trabaje por nosotros 24/7, conect√°ndose a una API externa, guardando la informaci√≥n de forma estructurada y haciendo todo esto de manera autom√°tica y gratuita. ¬°Vamos all√°!

---

### El Primer Paso: Hablar con la API de OpenWeatherMap

Todo servicio meteorol√≥gico necesita una fuente de datos. Eleg√≠ [OpenWeatherMap](https://openweathermap.org/) por su popularidad y su generoso plan gratuito. El proceso inicial es sencillo:

1.  **Registrarse**: Crear una cuenta en su web.
2.  **Obtener la API Key**: Generar una clave √∫nica que nos identificar√° en cada llamada. Es como nuestra "llave" para acceder a sus datos.
3.  **Guardar la Clave**: ¬°**Nunca** directamente en el c√≥digo! Hablaremos de esto m√°s adelante.

Con la clave en mano (¬°o casi!), escrib√≠ un primer script `test_clima.py` para probar la conexi√≥n usando la maravillosa librer√≠a `requests` de Python:

```python
import requests

API_KEY = "TU_API_KEY_AQUI" # ¬°Temporalmente! Luego usaremos Secretos
CIUDAD = "Madrid"
URL = f"[https://api.openweathermap.org/data/2.5/weather?q=](https://api.openweathermap.org/data/2.5/weather?q=){CIUDAD}&appid={API_KEY}&units=metric&lang=es"

try:
    respuesta = requests.get(URL)
    respuesta.raise_for_status() # Lanza un error si la respuesta no es 200 OK
    datos = respuesta.json()
    print(f"Temperatura en {CIUDAD}: {datos['main']['temp']}¬∞C")
except requests.exceptions.RequestException as e:
    print(f"Error al conectar con la API: {e}")
except KeyError as e:
    print(f"Respuesta inesperada de la API, falta la clave: {e}")
```

**Primer Obst√°culo Superado (con Paciencia):** Al ejecutarlo por primera vez, ¬°error 401: No Autorizado\! üò± Resulta que las API Keys de OpenWeatherMap pueden tardar unas horas en activarse despu√©s de generarlas. La lecci√≥n: a veces, la soluci√≥n es simplemente esperar. ‚è≥

-----

### La "Base de Datos": ¬øPor Qu√© CSV y No SQL?

Con los datos fluyendo, necesitaba almacenarlos. Podr√≠a haber montado una base de datos SQL (PostgreSQL, MySQL...), pero eso implicaba complejidad, un servidor (coste) y, para este proyecto, era matar moscas a ca√±onazos.

Opt√© por la simplicidad radical: **ficheros CSV (Comma Separated Values)**.

  * **Ventajas**: F√°ciles de leer y escribir con Python, perfectamente versionables con Git (podemos ver el historial de cambios), y suficientes para el volumen de datos que manejar√≠amos inicialmente.
  * **L√≥gica Clave**: Necesitaba a√±adir una nueva fila cada d√≠a a cada fichero de ciudad, pero escribiendo la cabecera (`fecha_hora`, `ciudad`, `temperatura_c`, etc.) solo la primera vez. La librer√≠a `csv` nativa de Python y `os.path.exists` lo hacen trivial:

```python
import csv
import os
from datetime import datetime

# ... (c√≥digo para obtener datos de la API para una ciudad) ...

ahora = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
fila_datos = [ahora, ciudad, temperatura, ...] # Lista con los datos
cabecera = ['fecha_hora', 'ciudad', 'temperatura_c', ...] # Lista con los nombres de columna
nombre_fichero = f"datos/{ciudad}.csv" # Creamos una carpeta 'datos'

# Asegurarse de que la carpeta 'datos' existe
os.makedirs(os.path.dirname(nombre_fichero), exist_ok=True)

es_archivo_nuevo = not os.path.exists(nombre_fichero)

try:
    with open(nombre_fichero, mode='a', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        if es_archivo_nuevo:
            writer.writerow(cabecera) # Escribir cabecera SOLO si es nuevo
        writer.writerow(fila_datos) # A√±adir la nueva fila de datos
    print(f"Datos guardados para {ciudad}")
except IOError as e:
    print(f"Error al escribir en {nombre_fichero}: {e}")
```

-----

### El Robot de Automatizaci√≥n: GitHub Actions al Rescate ü§ñ

Aqu√≠ viene la magia: ¬øc√≥mo hacer que este script se ejecute solo todos los d√≠as sin tener un servidor encendido? La respuesta es **GitHub Actions**, el motor de automatizaci√≥n integrado en GitHub. Es como tener un peque√±o robot que trabaja gratis para nosotros.

**La Seguridad Primero: ¬°Nunca Subas tu API Key\!**
El error m√°s grave ser√≠a subir `registrar_clima.py` con la `API_KEY` escrita directamente. Cualquiera podr√≠a verla en GitHub.

  * **Soluci√≥n**: Usar los **Secretos de Repositorio** de GitHub.
    1.  Ve a `Settings > Secrets and variables > Actions` en tu repositorio de GitHub.
    2.  Crea un nuevo secreto llamado `OPENWEATHER_API_KEY` y pega ah√≠ tu clave.
    3.  En el script Python, lee la clave de forma segura usando `os.environ.get("OPENWEATHER_API_KEY")`.

**El Cerebro del Robot: El Fichero `.github/workflows/actualizar-clima.yml`**
Este fichero YAML le dice a GitHub Actions qu√© hacer y cu√°ndo:

```yaml
name: Actualizar Datos Clim√°ticos Diarios

on:
  workflow_dispatch: # Permite lanzarlo manualmente desde GitHub
  push:
    branches: [ main ] # Se lanza si subimos cambios a la rama main
  schedule:
    - cron: '0 6 * * *' # La clave: se lanza cada d√≠a a las 6:00 UTC

jobs:
  actualizar_datos:
    runs-on: ubuntu-latest # Usamos una m√°quina virtual Linux gratuita
    steps:
      - name: Checkout del c√≥digo del repositorio
        uses: actions/checkout@v4 # Descarga nuestro c√≥digo

      - name: Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10' # O la versi√≥n que prefieras

      - name: Instalar dependencias necesarias
        run: pip install -r requirements.txt # Lee requirements.txt e instala requests, etc.

      - name: Ejecutar el script de recolecci√≥n de datos
        run: python registrar_clima.py # ¬°La acci√≥n principal!
        env:
          OPENWEATHER_API_KEY: ${{ secrets.OPENWEATHER_API_KEY }} # Inyectamos el secreto de forma segura

      - name: Guardar los nuevos datos en el repositorio (Commit & Push)
        run: |
          git config user.name 'github-actions[bot]' # Identifica al 'bot'
          git config user.email 'github-actions[bot]@users.noreply.github.com'
          git add datos/*.csv # A√±ade SOLO los ficheros CSV modificados en la carpeta 'datos'
          # Comprueba si hay cambios antes de hacer commit para evitar commits vac√≠os
          git diff --staged --quiet || git commit -m "Actualizaci√≥n autom√°tica de datos clim√°ticos ü§ñ"
          git push # Sube los cambios al repositorio
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Token autom√°tico para permitir el push
```

**¬°Este √∫ltimo paso es crucial\!** La propia Action act√∫a como un usuario, haciendo `git add`, `git commit` y `git push` de los ficheros CSV que el script Python acaba de modificar. As√≠, los datos actualizados quedan guardados en nuestro repositorio cada d√≠a.

-----

### El Problema de Escalar (y el Pivote de Arquitectura Necesario)

Mi idea inicial era monitorizar unas 1000 ciudades y guardar todo en un √∫nico fichero `datos_climaticos.csv`. Hice un c√°lculo r√°pido: 1000 ciudades \* \~200 bytes/d√≠a \* 365 d√≠as \* 3 a√±os... ¬°m√°s de 200 MB\! üò±

**¬øPor qu√© es un problema?** Porque el frontend (nuestro dashboard, que veremos en el pr√≥ximo post) se ejecuta en el navegador del usuario. Tendr√≠a que descargar esos 200 MB *completos* solo para mostrar el gr√°fico de *una* ciudad. Totalmente inaceptable en t√©rminos de rendimiento. üê¢

**La Soluci√≥n Arquitect√≥nica:** Cambiar a una estrategia de **"un fichero por entidad"**.

  * Creamos una carpeta `datos/`.
  * El script `registrar_clima.py` ahora genera (o a√±ade datos a) un fichero CSV por cada ciudad: `datos/Madrid.csv`, `datos/Le√≥n.csv`, `datos/Tokio.csv`, etc.

As√≠, cuando el usuario quiera ver el tiempo de Le√≥n, el frontend solo descargar√° el fichero `datos/Le√≥n.csv`, que pesar√° unos pocos kilobytes. ¬°La carga es instant√°nea\! ‚ú®

**Segundo Obst√°culo de Escalado (L√≠mites de API):** OpenWeatherMap, en su plan gratuito, permite unas 60 llamadas por minuto. Mi bucle para obtener datos de 155 ciudades (mi lista actual) las har√≠a demasiado r√°pido.

  * **Soluci√≥n Vital:** A√±adir `import time` al inicio del script Python y `time.sleep(1.1)` al final del bucle `for ciudad in ciudades:`. Esto introduce una pausa de poco m√°s de 1 segundo entre cada llamada a la API, asegurando que nos mantenemos por debajo del l√≠mite y evitamos que nos bloqueen. üö¶

-----

### Conclusi√≥n (Parte 1)

¬°Ya tenemos la base\! Hemos construido un sistema robusto y autom√°tico que:

  * Se conecta a una API externa de forma segura.
  * Procesa y almacena datos hist√≥ricos de m√∫ltiples entidades (ciudades).
  * Se ejecuta solo cada d√≠a, sin coste alguno, gracias a GitHub Actions.
  * Est√° dise√±ado para escalar de forma eficiente.

En el pr√≥ximo post, nos pondremos el sombrero de desarrollador frontend y construiremos el dashboard interactivo que permitir√° a cualquier usuario explorar estos datos con gr√°ficos din√°micos. ¬°No te lo pierdas\!

---

### Referencias y Enlaces de Inter√©s:

* **Servicio Web Completo**: Puedes ver el resultado final de este proyecto en acci√≥n aqu√≠: [https://dalaez.github.io/app_weather/](https://dalaez.github.io/app_weather/)
* **Repositorio GitHub del Proyecto**: Explora el c√≥digo fuente y la estructura del proyecto en mi repositorio: [https://github.com/Dalaez/app_weather](https://github.com/Dalaez/app_weather)
* **OpenWeatherMap**: Documentaci√≥n de la API de clima: [https://openweathermap.org/api](https://openweathermap.org/api)
* **Python Requests**: Documentaci√≥n de la librer√≠a para hacer peticiones HTTP: [https://requests.readthedocs.io/en/master/](https://requests.readthedocs.io/en/master/)
* **GitHub Actions**: Gu√≠a oficial de GitHub Actions: [https://docs.github.com/es/actions](https://docs.github.com/es/actions)